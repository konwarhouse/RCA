Provider list in UI, no env required (best practice)
What changes
Backend always returns a built-in list of supported providers (OpenAI, Anthropic, Google, Azure OpenAI). No AVAILABLE_AI_PROVIDERS needed.
UI shows those providers by default. User can paste an API key + model, click Test, Save, and Set active—all from the page.
Storage keeps provider rows in your DB (encrypted if a key exists; otherwise flagged “dev / insecure”).
Optional: if a secret RCA_KMS_KEY is present, API keys are AES-GCM encrypted at rest; if not present (dev), store plaintext but mark as insecure.
This gives zero-setup UX for external contributors while keeping a secure path for production.
1) Backend – supported provider list (static, no env gating)
server/config/aiProviders.ts
export type ProviderId = "openai" | "anthropic" | "google" | "azureopenai";

export const SUPPORTED_PROVIDERS: Array<{
  id: ProviderId;
  displayName: string;
  requiresApiKey: boolean;
  notes?: string;
}> = [
  { id: "openai",      displayName: "OpenAI",       requiresApiKey: true },
  { id: "anthropic",   displayName: "Anthropic",    requiresApiKey: true },
  { id: "google",      displayName: "Google Generative AI", requiresApiKey: true },
  { id: "azureopenai", displayName: "Azure OpenAI", requiresApiKey: true },
];
server/routes/aiProviders.ts
import { Router } from "express";
import { SUPPORTED_PROVIDERS } from "../config/aiProviders";
import { db } from "../db"; // your drizzle instance
import { aiProviders } from "../db/schema"; // your table
import { decryptIfNeeded, encryptIfPossible } from "../security/crypto";

const r = Router();

// List supported options for the dropdown (ALWAYS populated)
r.get("/supported", async (_req, res) => {
  res.json({
    providers: SUPPORTED_PROVIDERS, // no env needed
  });
});

// Return configured providers (rows in DB), with security flag
r.get("/", async (_req, res) => {
  const rows = await db.select().from(aiProviders);
  res.json({
    providers: rows.map(p => ({
      id: p.id,
      provider: p.provider,
      model: p.model,
      active: p.active,
      secure: p.encryption !== "none",
      createdAt: p.createdAt,
    })),
  });
});

// Create/update a provider (UI submits provider, model, apiKey)
r.post("/", async (req, res) => {
  const { provider, model, apiKey, active } = req.body ?? {};
  if (!provider || !model || !apiKey) {
    return res.status(422).json({ error: { code: "INVALID_REQUEST", message: "provider, model, apiKey required" }});
  }

  const { ciphertext, iv, tag, encryption } = await encryptIfPossible(apiKey);
  const [row] = await db.insert(aiProviders).values({
    provider, model,
    apiKeyEnc: ciphertext, iv, tag,
    encryption, active: !!active,
  }).returning();

  if (active) {
    await db.update(aiProviders).set({ active: false }).where(aiProviders.id.ne(row.id));
    await db.update(aiProviders).set({ active: true }).where(aiProviders.id.eq(row.id));
  }

  res.status(201).json({ id: row.id });
});

// Test credentials (simple ping per provider)
r.post("/test", async (req, res) => {
  const { provider, apiKey, model } = req.body ?? {};
  // Call minimal verify endpoint depending on provider
  try {
    // ... implement tiny per-provider verify (e.g., list models or make a trivial request)
    res.json({ ok: true });
  } catch (e:any) {
    res.status(400).json({ ok: false, error: e?.message || "Invalid key/model" });
  }
});

export default r;
Wire routes (server/app.ts)
import aiProvidersRouter from "./routes/aiProviders";
app.use("/api/v1/ai/providers", aiProvidersRouter);
2) Storage (Drizzle) – table for provider rows
server/db/schema/aiProviders.ts
import { pgTable, text, boolean, timestamp, uuid } from "drizzle-orm/pg-core";

export const aiProviders = pgTable("ai_providers", {
  id: uuid("id").defaultRandom().primaryKey(),
  provider: text("provider").notNull(),     // "openai" | "anthropic" | ...
  model: text("model").notNull(),           // e.g., "gpt-4o-mini"
  apiKeyEnc: text("api_key_enc").notNull(), // encrypted or plaintext (dev)
  iv: text("iv"),                           // encryption IV (if encrypted)
  tag: text("tag"),                         // auth tag (if encrypted)
  encryption: text("encryption").notNull().default("none"), // "aes-256-gcm" | "none"
  active: boolean("active").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow(),
});
Add a migration (via Drizzle) so fresh envs create this automatically.
3) Encryption helper (secure in prod, convenient in dev)
server/security/crypto.ts
import crypto from "crypto";

const K = process.env.RCA_KMS_KEY; // optional

export async function encryptIfPossible(plain: string) {
  if (!K) {
    return { ciphertext: plain, iv: null, tag: null, encryption: "none" as const };
  }
  const key = crypto.createHash("sha256").update(K).digest(); // 32 bytes
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);
  const enc = Buffer.concat([cipher.update(Buffer.from(plain, "utf8")), cipher.final()]);
  const tag = cipher.getAuthTag();
  return {
    ciphertext: enc.toString("base64"),
    iv: iv.toString("base64"),
    tag: tag.toString("base64"),
    encryption: "aes-256-gcm" as const,
  };
}

export function decryptIfNeeded(row: { apiKeyEnc: string; iv: string | null; tag: string | null; encryption: string }) {
  if (row.encryption !== "aes-256-gcm") return row.apiKeyEnc;
  if (!K || !row.iv || !row.tag) throw new Error("Missing KMS key/metadata");
  const key = crypto.createHash("sha256").update(K).digest();
  const iv = Buffer.from(row.iv, "base64");
  const tag = Buffer.from(row.tag, "base64");
  const decipher = crypto.createDecipheriv("aes-256-gcm", key, iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(Buffer.from(row.apiKeyEnc, "base64")), decipher.final()]);
  return dec.toString("utf8");
}
Prod: set RCA_KMS_KEY once; keys are encrypted at rest.
Dev: leave it unset; keys are stored plaintext but flagged encryption: "none" so the UI can show “(dev storage)”.
4) Frontend – dropdown always populated, no env
client/src/pages/admin/AiSettings.tsx (essentials)
// On mount:
const [{ providers: supported }, setSupported] = useState<{providers:any[]}>({ providers: [] });
useEffect(() => {
  fetch("/api/v1/ai/providers/supported").then(r => r.json()).then(setSupported);
}, []);

{/* Dropdown: always shows supported providers */}
<Select onValueChange={setProvider}>
  {supported.map(p => (
    <SelectItem key={p.id} value={p.id}>{p.displayName}</SelectItem>
  ))}
</Select>

{/* Fields: API key + model */}
<Input type="password" value={apiKey} onChange={e => setApiKey(e.target.value)} placeholder="API key" />
<Input value={model} onChange={e => setModel(e.target.value)} placeholder="Model ID (e.g., gpt-4o-mini)" />

<Button onClick={testKey}>Test Key</Button>
<Button onClick={saveProvider}>Save Settings</Button>

async function testKey() {
  const r = await fetch("/api/v1/ai/providers/test", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ provider, apiKey, model }),
  });
  const j = await r.json();
  toast(j.ok ? "Key works" : `Key failed: ${j.error || "Unknown error"}`);
}

async function saveProvider() {
  const r = await fetch("/api/v1/ai/providers", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ provider, model, apiKey, active: setActive }),
  });
  if (!r.ok) { /* show error */ return; }
  // refresh current provider list table
}
Current Providers table pulls /api/v1/ai/providers and shows:
Provider, Model, Active, Security: “Encrypted” vs “Dev (plaintext)”.
5) Migrations on boot (so table always exists)
Ensure your server runs Drizzle migrations on start (as we discussed earlier). That guarantees the ai_providers table is present in any fresh clone.